# 2021/07/30

## 第4周 继承与**多态**

**comment**

- 需要进行学习，还不够深入

---

面向对象程序设计语言有三大特性：**封装**、**继承**、**多态性**

### 继承

基于已有的设计创造新的设计，就是面向对象程序设计中的继承。

在继承中，新的类不是凭空产生的，而是基于一个已经存在的类而定义出来的。通过继承，新的类自动获得了基础类中所有的成员，包括成员变量和方法，包括各种访问属性的成员，无论是public还是private。

### 父类 子类

- 子类从父类得到父类的所有东西，包括：所有的父类的成员，包括变量和方法，都成为了子类的成员
  - **除了构造方法**。
    - 构造方法是父类所独有的，因为它们的名字就是类的名字，所以父类的构造方法在子类中不存在。除此之外，子类继承得到了父类所有的成员。。
- 有些父类的成员直接成为子类的对外的界面，有些则被深深地隐藏起来，即使子类自己也不能直接访问         



#### **构造方法：**

- 在构造一个子类的对象时，父类的构造方法也是会被调用的，而且**父类的构造方法在子类的构造方法之前被调用。**在程序运行过程中，子类对象的一部分空间存放的是父类对象。
  - 因为子类从父类得到继承，在子类对象初始化过程中**可能**会使用到父类的成员。所以父类的空间正是要先被初始化的，然后子类的空间才得到初始化。在这个过程中，如果父类的构造方法需要参数，如何传递参数就很重要了。



#### **多态变量**：

**一个变量可以保存其所声明的类型或该类型的任何子类型。**

- 对象变量可以保存其**声明的类型**的对象,或该类型的任何子类型的对象。
- Java中保存对象类型的变量是**多态变量**。“多态”这个术语(字面意思是许多形态)是指一个变量可以保存不同类型(即其声明的类型或任何子类型)的对象。

多态变量有2个类型：声明类型 + 动态类型。

- 在需要执行某个方法时，实际上是去执行其动态类型对应的方法。



#### **向上造型**

- 把子类的对象赋值给父类的变量的时候，就发生了向上造型
- 父类的变量可以接受任何子类的对象

#### 造型

如果父类的一个对象是实际上是其中一个子类，那么可以将该父类**造型**为其实际上是的子类

```java
public class Item//父类
{ 
    
}
public class CD extends Item //继承自Item的子类CD
{
    
}
Item it = new CD();

CD cd =(CD)it;
```







#### 多态



##### 覆盖override

子类和父类中存在名称和参数表完全相同的函数，这一对函数构成**覆盖关系**

- **通过父类的变量，调用存在覆盖关系的函数时，会调用变量当时所管理的对象所属的类的函数**

- 如果子类的方法**覆盖**了父类的方法，我们也说父类的那个方法在子类有了新的版本或者新的实现。

- 通过子类的对象调用这个方法，**执行**的是**子类自己的方法**。
  - 覆盖关系并不说明父类中的方法已经不存在了，而是当通过一个**子类的对象**调用这个方法时，子类中的方法取代了父类的方法，父类的这个方法被“覆盖”起来而看不见了。
  - 而当通过**父类的对象**调用这个方法时，实际上执行的仍然是父类中的这个方法。注意我们这里说的是对象而不是变量，因为一个类型为父类的变量有可能实际指向的是一个子类的对象。
  - 

多态变量有2个类型：声明类型 + 动态类型。

- 在需要执行某个方法时，实际上是去执行其动态类型对应的方法。
- 

##### **绑定**

当通过对象变量调用函数的时候，调用哪个函数这件事情叫做绑定



- **静态绑定**（早绑定）
  - 这种绑定在编译的时候就确定了；
  - **根据变量的声明类型来决定**
- **动态绑定**（晚绑定）
  - 动态绑定在运行的时候根据**变量当时实际所指的对象的类型**动态决定调用的方法。
  - Java默认（缺省）使用动态绑定
  - **根据变量的动态类型来决定**

在成员函数中调用其他成员函数也是通过this这个对象变量来调用的







---

#### 构造执行顺序：

- 0、进入子类的构造函数------不是执行

- 1、**执行**父类的构造函数
  - 确保父类所拥有的成员变量得到恰当的初始化
    - 定义初始化（先
    - 构造器（后
- 2、**执行**子类的定义初始化
- 3、**执行**子类的构造函数
